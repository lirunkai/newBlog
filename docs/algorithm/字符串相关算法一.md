**1. 寻找字符串最长不重复的子串**

思路:  

1. 遍历所有子串, 找到最大的无重复子串
2. `/(.).*\1/`可以找到重复的子串
3. 从最大的子串开始查找, 如查找到不重复则返回。

实现

```javascript
let longChildLength = function(s){
  if(s == '') return 0;
  let slen = s.length;
  let l = slen;
  let reRepeat = /(.).*\1/; // （）== \1 
  while(l > 1){
    for(let i = 0; i<slen - l + 1; i++){
      let temp = s.substr(i, l);
      console.log(`l:${l} -- i:${i} -- temp:${temp} -- ${reRepeat.test(temp)}`)
      if(!reRepeat.test(temp)) return temp
    }
    l --;
  }
  if(l == 1) return 1;
}

longChildLength('baczbabccsz')
```

[jsbin实现输出](https://jsbin.com/xobejez/edit?js,console)

2 给一个只有`()[]{}`的字符串, 检测他们.

```javascript
Example 1:

Input: "()"
Output: true
Example 2:

Input: "()[]{}"
Output: true
Example 3:

Input: "(]"
Output: false
Example 4:

Input: "([)]"
Output: false
Example 5:

Input: "{[]}"
Output: true

```



思路：

使用栈遍历输入字符串, 如果是右括号, 查看栈顶是否是对应的左括号, 如果不是返回false, 如果是, 栈顶出栈继续循环。 

```javascript
function isValid(s){
  let valid = true;
  const stack = [];
  const mapObj = {
    '{': '}',
    '[': ']',
    '(': ')'
  }
  for(let i in s){
    const v = s[i];
    // 入栈
    if(['(', '[', '{'].indexOf(v) > -1){
      stack.push(v)
    } else {
      // 检测是否出栈和返回false
      const peak = stack.pop()
      if(v !== mapObj[peak]){
				 valid = false
      }
    }
  }
  if(stack.length > 0) return false;
  return valid;
}
```

3 给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

> 回文字符串： `aba` 正反读都一样的 

性能不好的实现

```javascript
var longestPalindrome = function(s) {
    let returnStr = ""
    if(s.length > 1000) return returnStr;
    let sLen = s.length;
    let l = sLen;
    while(l > 0){
        for(let i = 0; i < sLen - l + 1; i++){
            let temp = s.substr(i, l)
            let newTemp = [...temp].reverse().join('')
            if(temp == newTemp){
                return temp;
            }
        }
        l --;
    }
    return returnStr;
};
```

性能好的实现

```javascript
var longestPalindrome = function (s) {
    if (!s || !s.trim()) return '';
    if (s.length === 1) return s;
    if (s.length === 2) return s[0] === s[1] ? s[0] + s[1] : s[0];
    
    var sArray = s.split('');
    var x = [...new Set(sArray)];
    var result;
    var result1;
    var result2;
    
    if (x.length === 1) return s;

    // 以item为对称点 找到回文串
    result1 = sArray.reduce(function(memo, item, idx, self) {
        var ret;

        if (idx === 0 ) return memo;
        if (typeof self[idx - 1] !== 'string' || self[idx - 1] !== self[idx + 1]) return memo;
        
        memo = (function () {
            var middle = idx;
            var i = 1;
            var result = item;
            
            while (typeof self[middle + i] === 'string' && typeof self[middle - i] === 'string' && self[middle + i] === self[middle - i]) {
                ++i;
            }
            
            if (i === 1) {                
                return memo;
            }
            
            i = i -1;
            result = self.slice(middle - i, middle + i+1).join('');

            return result.length > (memo && memo.length || 1) ? result : memo; 
        })();    
        
        return memo;
    }, sArray[0]);
    
    // 以item 和 next 两个一起为对称点 找到回文串
    result2 = sArray.reduce(function(memo, item, idx, self) {
         // axxa 中心轴是两个字母
        if (item !== self[idx + 1]) return memo;
        memo = (function () {
            var left = idx;
            var right = idx + 1;
            var i = 1;
            var result = item + item;
            
            while (typeof self[right + i] === 'string' &&typeof self[left - i] === 'string' && self[left - i] === self[right + i]) {
                ++i;
            }

            if (i === 1) return result.length > (memo && memo.length || 1) ? result : memo;
            
            i = i - 1;
            result = self.slice(left - i, right + i + 1).join('');

            return result.length > (memo && memo.length || 1)? result : memo;   
        })();

        return memo;
        
    }, sArray[0]);

    return result1.length > result2.length ? result1 : result2;   
}
```

