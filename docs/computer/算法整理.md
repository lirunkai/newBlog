## 算法整理

### 时间复杂度

大 O 表示法

如何分析时间复杂度？

1. 只关注循环执行次数最多的一段代码

```javascript
function solution(n) {
  let result = [];
  for (let i = 0; i < n; i++) {
    result.push(i);
  }
  return result;
}
```

由于循环执行次数最多的是第 4 行代码， 这行代码被执行了 n 次，所以总的时间复杂度就是 O(n)

```javascript
function solution(n) {
  let result = [];
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      result.push([i, j]);
    }
  }
  return result;
}
```

由于循环执行次数最多的是第 5 行代码， 这行代码被执行了 n\*n 次，所以总的时间复杂度就是 O(n^2)

```javascript
function findX(arr, n) {
  for (let x = 0; x < arr.length; x += 2) {
    if (arr[x] == n) {
      return x;
    }
  }
  return -1;
}
```

由于循环执行次数最多的是第 3,4, 行代码， 这行代码被执行了 n/2 次，所以总的时间复杂度就是 O(logn)

2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

3. 乘法法则: 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

复杂度量级（递增）

O（1） 常量

O(logn) 对数阶

O(n) 线性

O(n^2) 平方阶级

![](./../_media/大O.jpg)

### 空间复杂度

一个题型做到记忆深处之后, 再换另一个题型

### 数据结构

线性表数据结构

**数组**

在内存中连续存储

插入操作 O(n)

删除操作 O(n)

读取 O(1)

**链表**

链表（Linked List）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针（Pointer）。

**跳表**

链表加**多级索引**的结构，就是跳表

新增， 删除，需要维护其平衡性

**散列表** 也称为哈希表

**栈**

后入先出

使用： 浏览器的前进后退， 函数调用栈

1. [删除最外层的括号](https://leetcode-cn.com/problems/remove-outermost-parentheses/submissions/)

思路: 

遇到左括号入栈， 入栈后大与1， 说明有外层包裹
遇到右括号出栈， 出栈后大于0， 说明有外层包裹

```python
class Solution:
  removeOuterParentheses(self, S:str) -> str:
    stack, result = [], ''
    for k in S:
      if k == '(':
        stack.append(k)
        if len(stack) > 1:
          result += '('
      else:
        stack.pop()
        if len(stack) > 0:
          result += ')'
    return result
```

2. [用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

思路:

1. 创建一个输入栈， 一个输出栈
2. 添加元素时，先添加进输入栈
3. 删除元素时，看输出栈是否为空？不为空直接输出，为空则将输入栈的数据全部出栈进入输出栈再输出

```python
class CQueue:

  def __init__(self):
    self.in_stack = []
    self.out_stack = []
  
  def appendTail(self, value:int) -> None:
    self.in_stack.append(value)
  
  def deleteHead(self) -> int:
    if self.out_stack:
      return self.out_stack.pop()
    else:
      if self.in_stack:
        while self.in_stack:
          self.out_stack.append(self.in_stack.pop())
        return self.out_stack.pop()
      else:
        return -1

```

3. [删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

思路:
1. 设一个栈，每次入栈进行判断，如果上一个元素与当前元素一致， 则出栈

```python
class Solution:
  def removeDuplicates(self, S:str) -> str:
    stack = []
    for k in S:
      if stack and stack[-1] == k:
        stack.pop()
      else:
        stack.append(k)
    return ''.join(stack)
```

4. [棒球比赛](https://leetcode-cn.com/problems/baseball-game/submissions/)

给定一个字符串列表，每个字符串可以是以下四种类型之一：
1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。
2. "+"（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。
3. "D"（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。
4. "C"（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。

思路: 存储的是成绩， 而不是每次的比分

```python
class Solution:
  def calPoints(self, opts: List[str]) -> int:
    res, stack = 0, []
    for k in opts:
      if k == 'C':
        stack.pop()
      elif k == 'D':
        stack.append(stack[-1] * 2)
        res += stack[-1]
      elif k == '+':
        stack.append(stack[-1] + stack[-2])
        res += stack[-1]
      else:
        stack.append(int(k))
        res += stack[-1]
    return res
```

5. 用队列实现栈

```python
from collections import deque
class MyStack:
  def __init__(self) {
    self.data = deque()
    self.help = deque()
  }

  def push(self, x:int) -> None:
    self.data.append(x)
  
  def pop(self) -> int:
    while len(self.data) > 1:
      self.help.append(self.data.popleft())
    temp = self.data.popleft()
    self.help, self.data = self.data, self.help
    return temp

  def top(self) -> int:
    while len(self.data) >1:
      self.help.append(self.data.popleft())
    temp = self.data.popleft()
    self.help.append(temp)
    self.help, self.data = self.data, self.help
    return temp
  
  def isEmpty(self) -> bool:
    return not bool(self.data)
```

6. [下一个更大元素](https://leetcode-cn.com/problems/next-greater-element-i/)

思路: 

1. 求nums2中每个元素的下一个的最大值，并存储到字典中
2. num1直接读取字典中的值

```python
class Solution:
  def nextGeneratorElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
    stack, hashmap = [], dict()
    for k in nums2:
      while stack and stack[-1] < k:
        hashmap[stack.pop()] = k
      stack.append(k)
    return [hashmap.get(key, -1) for key in nums1]
```

7. [用栈操作构建数组](https://leetcode-cn.com/problems/build-an-array-with-stack-operations/)

思路:

一共就两种操作: 
1. 匹配 `Push`
2. 不匹配 `Push Pop`

```python
class Solution:
  def buildArray(self, target: List[int], n: int) -> List[str]:
      stack, j = [], 0
      if not target:
          return []
      for k in range(1, target[-1]+1): # 不使用n作为最终节点， target[-1]是循环遍历最大的值了
        if k == target[j]:
          stack.append('Push')
          #target.pop(0) # pop0会造成之后target元素的移动
          j += 1
        else:
          stack.extend(['Push', 'Pop'])
      
      return stack
```

8. [栈的最小值](https://leetcode-cn.com/problems/min-stack-lcci/)

思路:

1. 一个栈来存储输入的值
2. 一个栈来存储len的min值

```python
class MinStack:
  def __init__(self) {
    self.stack = []
    self.min_stack = []
  }

  def push(self, x:int) -> None:
    self.stack.append(x)
        if not self.min_stack or self.getMin() >= x:
            self.min_stack.append(x)
  
  def pop(self) -> None:
    if self.stack.pop() == self.getMin():
            self.min_stack.pop()

  def top(self) -> int:
    return self.stack[-1]

  def getMin(self) -> int:
    return self.min_stack[-1]
```

9. [比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/)

```python
class Solution:
  def backspaceCompare(self, S:str, T:str) -> bool:
    s_stack = []
    t_stack = []
    for i in S:
      if i == '#':
        if s_stack:
          s_stack.pop()
      else:
        s_stack.append(i)
    for j in T:
      if j == '#':
        if t_stack:
          t_stack.pop()
      else:
        t_stack.append(j)

    s = ''.join(s_stack)
    t = ''.join(t_stack)

    return s == t
```


**队列**

先入先出

使用： 循环队列， 阻塞队列， 并发队列， 排队请求

实现：

基于数组实现的是顺序队列

基于链表实现的是链式队列

循环队列实现时需要注意： 确定好空队列和队满的判定情况

1. 滑动窗口的最大值

给一个k，求nums列表中

思路：
1. 需要双端队列， 队首永远保持k范围内最大数
2. 判断最大值是否在新的k范围内 
```python
class Solution:
  def maxSlidingWindow(self, nums:List[int], k:int) -> List[int]:
    deque = collections.deque()
    res, n = [], len(n)

    for i, j in zip(range(i - k, n+1-k), range(n)):
      if i > 0 and deque[0] == nums[i - 1]:
        deque.popleft()
      while deque and deque[-1] < nums[j]:
        deque.pop()
      deque.append(nums[j])
      if i >0:
        res.append(deque[0])
```

### 算法

排序算法

### 快速排序

快速排序在最糟糕的情况下，也就是说取数每次都无法平分数组， 这种情况算法复杂度为 O(n2)

1.  三数取中法

2.

查找

### 二分算法

特征： 有序的数据集合， 每次都和区间的中间元素对比，将查找的区间缩小为之前的一半， 直到找到要查找的元素

1. [山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/submissions/)

输入：[0,1,0]

输出：1

输入：[0,2,1,0]

输出：1

思路： 分为上坡， 峰顶， 下坡。 通过中间节点和后一个元素的对比来确定使用左侧区间还是右侧区间

2. [寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)

   给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母

思路： 将最大的节点设置为 target， 比 target 大的都排除

3. [有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。

思路: 假设一个有序排列[0, .... num]， 使用二分法 将中间数的幂次方和 num 不断对比

4.

```javascript
// 1
// 2
// 3
// 4
```

### 字符串匹配

单模式匹配： 一个串和一个串进行匹配

### 链表

```python
class ListNode:
     def __init__(self, x):
         self.val = x
         self.next = None
```

1. 反转一个单链表

```python
// input: 1 -> 2-> 3-> 4-> 5-> NULL
// out: 5 -> 4 -> 3 -> 2-> 1-> NULL

class Solution:
  def reverseList(self, head):
    cur, prev = head, None

    while cur:
      cur.next, prev, cur = prev, cur, cur.next

    return prev
```

```javascript
var reverseList = function (head) {
  let cur = head;
  let pre = null;
  let temp = "";
  if (head == null) return head;
  while (cur != null) {
    temp = cur.next;
    cur.next = pre;
    pre = cur;
    cur = temp;
  }
  return pre;
};
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null) {
            return head;
        }
        ListNode pre = null;
        ListNode cur = head;
        ListNode temp;
        while(cur != null) {
            temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}

```

2. 交换相邻元素
   input: 1->2->3->4
   output: 2->1->4->3

```python
class Solution:
  def swapPairs(self, head):
    pre, pre.next = self, head
    while pre.next and pre.next.next:
      a = pre.next
      b = a.next
      pre.next, b.next, a.next = b, a, b.next
      pre = a

    return self.next

```

3. 判断链表是否有环

快慢指针解法

```python
class Solution:
  def hasCycle(self, head):
    fast = slow = head
    while slow and fast and fast.next:
      slow = slow.next
      fast = fast.next.next
      if slow is fast:
        return True
    return False
```

4. 删除中间节点

实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。

```
输入：单向链表a->b->c->d->e->f中的节点c
结果：不返回任何数据，但该链表变为a->b->d->e->f
```

思路：把 c 的值赋值为 d, c 的 next 节点赋值为 e, 删除了 d 节点

```python
class Solution:
  def deleteNode(self, node):
    low, fast = head, head
    while fast and fast.next:
      low = low.next
      fast = fast.next.next
    low.val = low.next.val
    low.next = low.next.next
```

5. 二进制链表转整数

给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式

```python
def getDecimalValue(self, head:ListNode) -> int:
    ans, cur = 0, head
    while cur is not None:
        ans = ans * 2 + cur.val
        cur = cur.next
    return ans
```

```python
def getDecimalValue(self, head:ListNode) -> int:
  ans, cur = 0, head
  while cur is not None:
    ans = (ans << 1) | cur.val
    cur = cur.next
  return ans
```

6. 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

```
输入： 1->2->3->4->5 和 k = 2
输出： 4
```

```python
def kthToLast(self, head:ListNode, k:int) -> int:
  low, fast = head,, head
  while k:
    fast = fast.next
    k -= 1
  while fast is not None:
    fast = fast.next
    low = low.next
  return low.val
```

7. 移除重复节点

编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

输入：[1, 2, 3, 3, 2, 1]
输出：[1, 2, 3]

思路: 

+ 建一个缓冲区
+ 如果缓冲区内有这个节点，则将指针指向后一个节点， 也就是删除这个节点。
+ 如果缓冲区内没有这个节点，加入缓冲区

```python
class Solution:
  def removeDuplicateNodes(self, head: ListNode) -> ListNode:
    s_val = set()
    pre = ListNode(-1)
    pre.next = head
    while pre.next:
      if pre.next.val in s_val:
        pre.next = pre.next.next
      else:
        s_val.add(pre.next.val)
        pre = pre.next
    return head
```

8. 获取中间节点

```python
class Solution:
  def middleNode(self, head:ListNode) -> ListNode:
    low, fast = head, head
    while fast and fast.next:
      low = low.next
      fast = fast.next.next
    return low
```

9. 链表相交

给定两个单链表, 如果两个链表相交， 返回相交点。 如果不相交返回null

思路:

如果相交： headA链表 + headB链表和 headB链表 + headA链表的走过的总节点是一致的， 到相交节点会一致

如果不相交, 返回最后的null

```python
class Solution:
  def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
    ta = headA
    tb = headB
    while ta != tb:
      ta = ta.next if ta else headB
      tb = tb.next if tb else headA
    return tb
```

10. 合并两个有序列表

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

```python
class Solution:
  def mergeTwoList(self, l1:ListNode, l2: ListNode) -> ListNode:
    if not l1: return l2
    if not l2: return l1
    if l1.val <= l2.val:
      l1.next = self.mergeTwoList(l1.next, l2)
      return l1
    if l1.val > l2.val:
      l2.next = self.mergeTwoList(l1, l2.next)
      return l2
```

11. 回文链表

输入： 1->2
输出： false 

输入： 1->2->2->1
输出： true 

思路: 回文链表， 后半部分翻转之后和前半部分一致， 一一对比

```python
class Solution:
  def isPalindrome(self, head:ListNode) -> bool:
    low = fast = head
    while fast and fast.next:
      low = low.next
      fast = fast.next.next
    
    pre = None
    cur = low
    while cur:
      cur.next, pre, cur = pre, cur, cur.next

    while head and pre:
      if head.val != pre.val:
        return False

      head = head.next
      pre = pre.next
    
    return True
```

### 堆栈 Stack FILO(first-in-last-out)

1. 给定一个只包含大、中、小括号的字符串，判断字符串是否有效

input： `(){}[]`

output: true

input: `([)]`

output: false

```python
class Solution:
  def isValid(self, s):
    stack = []
    paren_map = {')': '(', ']':'[', '}': '{'}
    for c in s:
      if c not in paren_map:
        stack.append(c)
      elif not stack or paren_map[c] != stack.pop():
        retuen False

    return not stack
```

2. 使用栈实现队列效果

### 队列 Queue FIFO(first-in-first-out)

### 优先队列 PriorityQueue

1. 实时判断数据流中第 k 大元素

```java
class KthLargest {
  final PriorityQueue<Integer> q;
  final int k;
  public KthLargest(int k, int[] a) {
    this.k = k;
    q = new PriorityQueue<>(k);
    for (int n : a)
      add(n)
  }

  public int add(int n) {
    if (q.size() < k)
      q.offer(n)
    else if(q.peek() < n) {
      q.pool()
      q.offer(n)
    }
    return q.peek()
  }
}
```

```python
import heapq
class KthLargest:
  def __init__(self, nums):
    self.k = k

    self.heap = nums
    heapq.heapify(self.heap)

```

### 双指针

1. 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

input: s = 'abc' t= 'ahbgdc'

output: true

input: s = "axc", t = "ahbgdc"

output: false

```python
class Solution:
  def isSubsequence(self, s: str, t: str) -> bool:
    n, m = len(s), len(t)
    i = j = 0
    while(i < n and j < m):
      if(s[i] == t[j]):
        i += 1
      j += 1
    return i == n
```

### 树

最顶极节点称为 根节点

完全二叉树： 每个节点都有两个子节点

```python
class TreeNode:
  def __init__(self, val):
    self.val = val
    self.left, self.right = None, None
```

二叉搜索树:

1. 左子树上所有结点的值均小于它的根结点的值

2. 右子树上所有结点的值均大于它的根结点的值

特殊情况下的二叉搜索树：

子节点都在左子树， 子节点都在右子树， 查找的时间复杂度退化为 O（n）

为了解决这个问题 出现了红黑树

树的三种遍历

1. 前序遍历 Pre-order 根 - 左 - 右

```python
def preorder(self, root):
  if root:
    self.traverse_path.append(root.val)
    self.preorder(root.left)
    self.preorder(root.right)
```

2. 中序遍历 In-order 左 - 根 - 右

```python
def inorder(self, root):
  if root:
    self.inorder(root.left)
    self.traverse_path.append(root.val)
    self.inorder(root.right)
```

3. 后序遍历 Post-order 左 - 右 - 根

```python
def postorder(self, root):
  if root:
    self.postorder(root.left)
    self.postorder(root.right)
    self.traverse_path.append(root.val)
```

1. 验证二叉搜索树

```python

def helper(self, root):
  if root is None:
    return True
  if not self.helper(root.left):
    return False
  if not self.helper(root.right)

```

2. 二叉树最近公共祖先

递归解法

```python
def lowestCommonAncestor(self, root, p, q):
  if p.val < root.val > q.val:
    return self.lowestCommonAncestor(root.left, p, q)
  if p.val > root.val < q.val:
    return self.lowestCommonAncestor(root.right, p, q)
  return root
```

while 循环 和递归一样

```python
def lowestCommonAncestor(self, root, p, q):
  while root:
    if p.val < root.val > q.val:
      root = root.left
    if p.val > root.val < q.val:
      root = root.right
    else:
      return root
```

3。 N叉树的前序遍历

```python
class Solution:
    def preorder(self, root: 'Node') -> List[int]:
      if root is None:
        return []
      
      stack, res = [root,], []
      while stack:
        root = stack.pop()
        res.append(root.val)
        stack.extend(root.children[::-1])
      return res
```

4. 验证二叉搜索树

一个二叉搜索树具有如下特征：
  节点的左子树只包含小于当前节点的数。
  节点的右子树只包含大于当前节点的数。
  所有左子树和右子树自身必须也是二叉搜索树。

解法1: 中序遍历
```python
class Solution:
  def isValidBST(self, root: TreeNode) -> bool:
    res = []
    def inorder(root):
      if root is None: return
      inorder(root.left)
      res.append(root.val)
      inorder(root.right)
    inorder(root)
    return res == sorted(res) and len(set(res)) == len(res)
```
解法2: 动态更新上界和下界

当前节点的值是其左子树的值的上界（最大值）
当前节点的值是其右子树的值的下界（最小值）

```python
class Solution:
  def isValidBST(self, root: TreeNode) -> bool:
    return self.dg(root, -(2**32), 2**32)
  
  def dg(self, root, min_v, max_v):
    if root is None:
      return True
    
    if root.val < max_v and root.val > min_v:
      pass
    else:
      return False

    if self.dg(root.left, min_v, root.val) == False:
      return False

    if self.dg(root.right, root.val, max_v) == False:
      return False

    return True
```

5. 二叉树的最大深度

```python
class Solution:
  def maxDeepCount(self, root: TreeNode) -> int:
    if not root:
      return 0
    
    return max(self.maxDeepCount(root.left), self.maxDeepCOunt(root.right)) + 1
```

6. 二叉树的最小深度

深度优先解法
```python
class Solution:
  def minDepth(self, root: TreeNode) -> int:
    if not root:
      return 0
    
    if not root.left and not root.right:
      return 1
    
    min_depth = 10**9
    if root.left:
      min_depth = min(self.minDepth(root.left), min_depth)
    if root.right:
      min_depth = min(self.minDepth(root.right), min_depth)

    return min_depth + 1
```

广度优先
```python
class Solution:
  def minDepth(self, root: TreeNode) -> int:
    if not root:
      return 0
    
    que = collecions.deque([(root, 1)])
    
    while que:
      node, depth = que.popleft()

      if not node.left and not node.right:
        return depth
      
      if node.left:
        que.append((node.left, depth + 1))
      if node.right:
        que.append((node.right, depth + 1))
      
    return 0
```

### 图

### 递归&&分治

1. Pow（x, n）

```python

```

2. 求众数

Majonity 某个数出现的次数大于数组的 1/2

```python

```

### 贪心算法

在对问题求解时，总是作出对当前最优的解法

贪心算法与动态规划的不同在于它对于每个子问题的解决方案都作出选择，不能回退。

动态规划会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能
