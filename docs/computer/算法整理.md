## 算法整理

### 时间复杂度

大 O 表示法

如何分析时间复杂度？

1. 只关注循环执行次数最多的一段代码

```javascript
function solution(n) {
  let result = [];
  for (let i = 0; i < n; i++) {
    result.push(i);
  }
  return result;
}
```

由于循环执行次数最多的是第 4 行代码， 这行代码被执行了 n 次，所以总的时间复杂度就是 O(n)

```javascript
function solution(n) {
  let result = [];
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      result.push([i, j]);
    }
  }
  return result;
}
```

由于循环执行次数最多的是第 5 行代码， 这行代码被执行了 n\*n 次，所以总的时间复杂度就是 O(n^2)

```javascript
function findX(arr, n) {
  for (let x = 0; x < arr.length; x += 2) {
    if (arr[x] == n) {
      return x;
    }
  }
  return -1;
}
```

由于循环执行次数最多的是第 3,4, 行代码， 这行代码被执行了 n/2 次，所以总的时间复杂度就是 O(logn)

2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

3. 乘法法则: 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

复杂度量级（递增）

O（1） 常量

O(logn) 对数阶

O(n) 线性

O(n^2) 平方阶级

![](./../_media/大O.jpg)

### 空间复杂度

一个题型做到记忆深处之后, 再换另一个题型

### 数据结构

线性表数据结构

**数组**

在内存中连续存储

插入操作 O(n)

删除操作 O(n)

读取 O(1)

**链表**

一个元素的 next 指针指向下一个元素， 链起来就是链表

**跳表**

链表加**多级索引**的结构，就是跳表

新增， 删除，需要维护其平衡性

**散列表** 也称为哈希表

**栈**

后入先出

使用： 浏览器的前进后退， 函数调用栈

**队列**

先入先出

使用： 循环队列， 阻塞队列， 并发队列， 排队请求

实现：

基于数组实现的是顺序队列

基于链表实现的是链式队列

循环队列实现时需要注意： 确定好空队列和队满的判定情况

### 算法

排序算法

### 快速排序

快速排序在最糟糕的情况下，也就是说取数每次都无法平分数组， 这种情况算法复杂度为 O(n2)

1.  三数取中法

2.

查找

### 二分算法

特征： 有序的数据集合， 每次都和区间的中间元素对比，将查找的区间缩小为之前的一半， 直到找到要查找的元素

1. [山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/submissions/)

输入：[0,1,0]
输出：1
输入：[0,2,1,0]
输出：1

思路： 分为上坡， 峰顶， 下坡。 通过中间节点和后一个元素的对比来确定使用左侧区间还是右侧区间

2. [寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)
   给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母

思路： 将最大的节点设置为 target， 比 target 大的都排除

3. [有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。

思路: 假设一个有序排列[0, .... num]， 使用二分法 将中间数的幂次方和 num 不断对比

4.

```javascript
// 1
// 2
// 3
// 4
```

### 字符串匹配

单模式匹配： 一个串和一个串进行匹配

### 链表

1. 反转一个单链表

```python
// input: 1 -> 2-> 3-> 4-> 5-> NULL
// out: 5 -> 4 -> 3 -> 2-> 1-> NULL

class Solution:
  def reverseList(self, head):
    cur, prev = head, None

    while cur:
      cur.next, prev, cur = prev, cur, cur.next

    return prev
```

```javascript
var reverseList = function (head) {
  let cur = head;
  let pre = null;
  let temp = "";
  if (head == null) return head;
  while (cur != null) {
    temp = cur.next;
    cur.next = pre;
    pre = cur;
    cur = temp;
  }
  return pre;
};
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null) {
            return head;
        }
        ListNode pre = null;
        ListNode cur = head;
        ListNode temp;
        while(cur != null) {
            temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}

```

2. 交换相邻元素
   input: 1->2->3->4
   output: 2->1->4->3

```python
class Solution:
  def swapPairs(self, head):
    pre, pre.next = self, head
    while pre.next and pre.next.next:
      a = pre.next
      b = a.next
      pre.next, b.next, a.next = b, a, b.next
      pre = a

    return self.next

```

3. 判断链表是否有环

快慢指针解法

```python
class Solution:
  def hasCycle(self, head):
    fast = slow = head
    while slow and fast and fast.next:
      slow = slow.next
      fast = fast.next.next
      if slow is fast:
        return True
    return False
```

set 存储法

```python

```

### 堆栈 Stack FILO(first-in-last-out)

1. 给定一个只包含大、中、小括号的字符串，判断字符串是否有效

input： `(){}[]`
output: true

input: `([)]`
output: false

```python
class Solution:
  def isValid(self, s):
    stack = []
    paren_map = {')': '(', ']':'[', '}': '{'}
    for c in s:
      if c not in paren_map:
        stack.append(c)
      elif not stack or paren_map[c] != stack.pop():
        retuen False

    return not stack
```

2. 使用栈实现队列效果

### 队列 Queue FIFO(first-in-first-out)

### 优先队列 PriorityQueue

1. 实时判断数据流中第 k 大元素

```java
class KthLargest {
  final PriorityQueue<Integer> q;
  final int k;
  public KthLargest(int k, int[] a) {
    this.k = k;
    q = new PriorityQueue<>(k);
    for (int n : a)
      add(n)
  }

  public int add(int n) {
    if (q.size() < k)
      q.offer(n)
    else if(q.peek() < n) {
      q.pool()
      q.offer(n)
    }
    return q.peek()
  }
}
```

```python
import heapq
class KthLargest:
  def __init__(self, nums):
    self.k = k

    self.heap = nums
    heapq.heapify(self.heap)

```

### 双指针

1. 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

input: s = 'abc' t= 'ahbgdc'
output: true

input: s = "axc", t = "ahbgdc"
output: false

```python
class Solution:
  def isSubsequence(self, s: str, t: str) -> bool:
    n, m = len(s), len(t)
    i = j = 0
    while(i < n and j < m):
      if(s[i] == t[j]):
        i += 1
      j += 1
    return i == n
```
