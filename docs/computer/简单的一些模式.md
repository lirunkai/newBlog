# 简单的一些模式

## 外观模式（适配器模式）

个人理解外观模式就是对一些方法进行包装, 使用户使用起来感觉不到子代码的差异性

```
function addEvent(dom, event, fn){
  if(dom.addEventListener){
    dom.addEventListener(event, fn, false)
  } else {
    dom.attachEvent('on' + event, fn)
  }
}

```


## 单例模式

类只有一个实例,比如全局缓存,全局状态管理等都只需要一个实例.

```
let nameSpace = {
  name: 'bg',
  age: 15
}
```


## 装饰者模式

在不修改原对象的情况下， 对对象的功能进行添加。

要装饰的功能放在单独的函数里, 然后用该函数包装要装饰的已有函数对象。

主要是想把一个类的主要功能和装饰功能分隔开来

## 命令模式

命令模式的目标是将方法的调用,请求或者操作封装到一个单独的对象中,给我们酌情执行同时参数化和传递方法调用的能力.

```
(function (){
  let Car = {
    xi(model, id){
      return `my cat is ${model}, id is ${id}`
    },
    buy(model, id){
      return `you can search my car ${model}`
    },
    notM(model, id){
      return `you can buy ${model}, or use it`
    },
    execute(name){
      return Car[name] && Car[name].call(Car, [].slice.call(arguments, 1))
    }
  }
  })()


Car.execute('buy', 'baoma', '321')
Car.execute('notM', 'benchi', '321')
```

## 代理模式

为一个对象提供一个代理用品或者占位符, 以便控制对它的访问。

*缓存代理*

*验证代理*

*私有代理*

```

```
