# 网络

与其他电脑进行交流

## IP 地址

当设备连接网络，设备将被分配一个 IP 地址，用作标识。

通过 IP 地址，设备间可以互相通讯，如果没有 IP 地址，我们将无法知道哪个设备是发送方，无法知道哪个是接收方

一般 IP 地址分为: `IPv4` 和 `IPv6`两大类

IPv4: 32 位二进制数组成

IPv6: 128 位二进制数组成

## IP 协议

根据源主机和目的主机的地址来传送数据

IP 定义了寻址方法和数据报的封装结构

## UDP

`User Datagram Protocol` 用户数据报协议

尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态

无连接 位于传输层

## TCP

`Transmisson Control Protocol` 传输控制协议

提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达

三个阶段: 创建通道 -> 数据传输 -> 通道关闭

面向连接 位于传输层

三次握手（创建通道）

1. 客户端发送`SYN`(连接请求)到服务器
2. 服务端接受`SYN`(连接请求)并回返一个`SYN/ACK`(连接确认)
3. 客服端收到`SYN/ACK`, 发送`ACK`(确认)

> 如果中间客户端掉线了？？

> 如果服务器端接到了客户端发的 SYN 后回了 SYN-ACK 后客户端掉线了，服务器端没有收到客户端回来的 ACK，那么，这个连接处于一个中间状态，既没成功，也没失败。于是，服务器端如果在一定时间内没有收到的 TCP 会重发 SYN-ACK。在 Linux 下，默认重试次数为 5 次，重试的间隔时间从 1s 开始每次都翻倍，5 次的重试时间间隔为 1s, 2s, 4s, 8s, 16s，总共 31s，第 5 次发出后还要等 32s 才知道第 5 次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP 才会断开这个连接。使用三个 TCP 参数来调整行为：tcp_synack_retries 减少重试次数；tcp_max_syn_backlog，增大 SYN 连接数；tcp_abort_on_overflow 决定超出能力时的行为。

四次挥手(关闭通道)

1. 客户端发出连接释放(`FIN`)的请求
2. 服务端收到连接释放报文(`FIN`)，发出确认(`ACK`)报文
3. 服务端确认将数据传送完毕之后, 向客户端发送连接释放(`FIN`)报文
4. 客户端收到连接释放报文, 发送确认(`ACK`)报文

TCP 如何提供传输的可靠性?

1. 在每个 TCP 报文段中都有一对序号和确认号, TCP 报文的接收者为了确保可靠性，在接收到一定数量的连续字节流后才发送确认 -> 选择确认
1. 选择确认使得 TCP 接收者可以对乱序到达的数据块进行确认。每一个字节传输过后，SN 号都会递增 1。
1. 数据分割, 应用数据被分割成 TCP 认为的最合适的长度进行发送
1. 重传, 当 TCP 发出一个报文段后, 它启动一个定时器,等待目的端确认收到这个报文段。如果不能及时收到则重发
1. TCP 将保持它首部和数据的校验. 如果有差错抛弃

## HTTP

`HyperText Transfer Protocol` 超文本传输协议，默认 80 端口

1. `Connection: Keep-Alive` 使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。

### HTTP2.0

和 HTTP1 的区别

1. 二进制传输, 之前的数据传输使用的是文本, 现在使用的传输方式是二进制
2. 多路复用。
   帧和流。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。
   多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。
3. Header 压缩
   HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。
4. 服务端 Push。 服务端可以在客户端某个请求后，主动推送其他资源。

### HTTPS

`HyperText Transfer Protocol Secure` 超文本传输安全协议，默认 443 接口

HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。

在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。

对称加密: 两边持有相同的密钥

非对称加密: 有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。

### http状态码

200: ok

301: 永久重定向

302: 临时重定向

304: 协商缓存

#### Http代理 nginx

代理服务器

+ 对客户端而言，表现为服务器相应
+ 对源服务器而言, 表现为客户端发起请求

功能

1. 负载均衡
2. 保障安全
3. 缓存代理

## DNS

DNS 域名解析

1. 浏览器搜索自己的 DNS 缓存
2. 查找本地操作系统
3. 查找本地系统`/etc/hosts（mac）`
4. 在本地区域名服务器进行查找

位于应用层

### URL 输入之后到页面加载完成,都经历了什么

1. DNS 查询
2. TCP 握手
3. web 浏览器向 web 服务器发送 HTTP 报文
4. 数据在进入服务端之前, 会经过负载均衡，服务器返回 html
5. 浏览器判断状态码, 200 继续解析, 300 重定向, 400 和 500 会报错
6. 浏览器解析文件，如果是 gzip 格式的话需要解压, 根据文件的编码格式进行解码
7. 构建 DOM Tree, CSSOM
8. CSSOM 树和 DOM 树构建完成后会开始生成 Render 树
9. 浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了

## FTP

`File Transfer Protocol` 文件传输协议

## SMTP

`Simple Mail Transfer Protocol` 简单邮件传输协议

## SSH

`Secure Shell` 加密的网络协议

## 同源策略

协议，域名，端口都一致

限制行为：

1. Cookie, LocalStorage 的读取
2. DOM 和 JS 对象无法获取
3. Ajax 请求无法发送

解决：

1. CORS(cross-origin-resource-sharing) 跨域资源共享, 定义了必须在访问跨域资源时，浏览器和服务情应该如何沟通

   服务端设置

   `Access-Control-Allow-Origin`就可以开启 CORS

   `Access-Control-Allow-Credentials` 允许携带 cookie

2. document.domain

   适用于二级域名相同的情况下

3. postMessage

   这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息, 另一个页面判断来源并接受消息

   ```
   // 发送消息端
   window.parent.postMessage(data, 'http://bababa.com')
   // 消息接受端
   const mc = new MessageChannel()
   mc.addEventListener('message', (event) => {
   	let origin = event.origin || event.originalEvent.origin
   	if(origin == 'http://bababa.com') {
   		console.log(event.data)
   	}
   })
   ```

**携带 Cookie**
xhr: withcredient

## Websocket

HTML5 的一个持久化的协议， 实现了浏览器与服务器的全双工通信。

### Ajax

### Fetch

`fetch(url，init)` 返回一个`Promise`, `resolve`对应请求的`Response`



### 请求方法

get: 通常用来获取资源

post: 提交资源

put: 修改资源

delete: 删除资源

option: 列出可对资源实行的请求方法, 用来跨域请求

**get和post**的区别

+ get请求会被浏览器主动缓存，留下历史记录，post默认不会
+ get只能进行URL编码, POST没有限制
+ get参数一般放在URL中, 不安全。 post参数放在请求体中,更适合传输敏感信息



