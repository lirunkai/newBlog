手写代码

## **手写 new 操作符**

`new`实现了什么?

- 创建了全新的对象
- `__proto__`的指向
- this 指向新创建的对象

```javascript
function New() {
  let obj = {};
  let [constructor, ...args] = [...arguments];
  obj.__proto__ = constructor.prototype;

  let result = constructor.apply(obj, args);

  if ((result && typeof result === "function") || typeof result === "object") {
    return result;
  }
  return obj;
}
```

## **手写 call**

`call` 改变了 this 的指向,直接调用了函数

this 值

谁调用的函数， this 指向就是谁

```javascript
Function.prototype.call2 = function () {
  let [thisArg, ...args] = [...arguments];
  thisArg = Object(thisArg) || window;
  let fn = Symbol();
  thisArg[fn] = this;
  let result = thisArg[fn](...args);
  delete thisArg[fn];
  return result;
};
```

### **手写 Apply**

apply 传入的是一个数组

```javascript
Function.prototype.apply2 = function (thisArg = window) {
  let [thisArg, args] = [...args];
  thisArg = Object(thisArg);
  let fn = Symbol();
  thisArg[fn] = this;
  let result = thisArg[fn](...args);
  delete thisArg.fn;
  return result;
};
```

### **bind**

和 call 相比多了处理`prototype`的部分，返回的是一个函数

```javascript
Function.prototype.bind2 = function (content) {
  if (typeof this !== "function") {
    throw Error("not a function");
  }
  let fn = this;
  let args = [...arguments].slice(1);

  let resFn = function () {
    return fn.apply(this instanceof resFn ? this : content, args);
  };
  function tmp() {}
  tmp.prototype = this.prototype;
  resFn.prototype = new tmp();
  return resFn;
};

Function.prototype.myBind = function (context, ...args) {
  return (...newArgs) => {
    return this.call(context, ...args, ...newArgs);
  };
};
```

### **instanceOf**

思路： 递归查找父原型

```javascript
function instanceOf(left, right) {
  if (typeof left !== "object" || left == null) return;
  let leftProto = left.__proto__;
  let rightProto = right.prototype;
  while (true) {
    if (leftProto == null) return false;
    if (leftProto == rightProto) return true;
    leftProto = leftProto.__proto__;
  }
}
```

### sleep 函数

某个时间后执行函数

```javascript
function sleep(fn, time) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(fn);
    }, time);
  });
}
```

### 实现 reduce

```javascript
Array.prototype.myreduce = function (fn, initVal) {
  let result = initVal;
  let i = 0;
  if (typeof initVal === "undefined") {
    result = this[i];
    i++;
  }
  while (i < this.length) {
    result = fn(result, this[i]);
  }

  return result;
};
```

### **Promise**

```javascript

```

### **EventBus**

随 Vue 声明周期的 EventBus

```javascript
class EventBus{
  constructor(vue){
    if(!this.handles){
      Object.defineProperty(this, 'handles', {
        value: {},
        enumerable: false
      })
    }
    this.Vue = vue
    this.eventMapUid = {}
  }

  setEventMapUid(uid, eventName){
    if(!this.eventMapUid[uid]) this.eventMapUid[uid] = []
    this.eventMapUid[uid].push(eventName)
  }

  $on(eventName, callback,vm){
    if(!this.handles[eventName]) this.handles[eventName] = []
    this.handles[eventName].push(callback)
    if(vm instanceOf this.Vue) this.setEventMapUid(vm._uid, eventName)
  }

  $emit(){
    let args = [...arguments]
    let eventName = args[0]
    let params = args.slice(1)
    if(this.handles[eventName]){
      let len = this.handles[eventName].length
      for(let i =0; i< len; i++){
        this.handles[eventName][i](...params)
      }
    }
  }

  $offVmEvent(uid){
    let currentEvents = this.eventMapUid[uid] || []
    currentEvents.forEach(event => {
      this.$off(event)
    })
  }

  $off(eventName){
    delete this.handles[eventName]
  }
}

// vue 插件
let $EventBus = {}
$EventBus.install = (Vue, option) => {
  Vue.prototype.$eventBus = new EventBus(Vue)
  Vue.mixin({
    beforeDestroy(){
      this.$eventBus.$offVmEvent(this._uid)
    }
  })
}

export default $EventBus
```

### 手写节流

节流: 规定时间内只能触发一次函数， 如果触发多次，只有一次生效 （scroll 滚动事件，每隔一定事件执行函数）

```javascript
function throttle(fn, delay) {
  let flag = true,
    timer = null;
  return function (...args) {
    let context = this;
    if (!flag) return;

    flag = false;
    clearTimeout(timer);
    timer = setTimeout(function () {
      fn.apply(context, args);
      flag = true;
    }, delay);
  };
}
```

### 手写防抖

防抖: 在事件被触发 n 秒后再执行回调， 如果这 n 秒内又被触发，则重新计时

应用场景:

- 登陆，短信等按钮避免多次发送请求
- 浏览器修改 resize 大小避免多次渲染

```javascript
function debounce(fn, delay) {
  let timer = null;
  return function (...args) {
    let context = this;
    if (timer) clearTimeout(timer);
    timer = setTimeout(function () {
      fn.apply(context, args);
    }, delay);
  };
}
```

### 事件委托

```javascript
function delegate(element, eventName, sourceType, fn) {
  element.addEventListener(
    eventName,
    (e) => {
      let target = e.target;
      while (!target.match(sourceType)) {
        // 结束条件
        if (element == target) {
          target = null;
          break;
        }
        target = el.parentNode;
      }
      target && fn.call(target, e, target);
    },
    true
  );
  return element;
}
```

### 实现一个可拖动的 div

```javascript
let dragable = false;
let position = null;

element.addEventListener("mousedown", (e) => {
  dragable = true;
  position = [e.clientX, e.clientY];
});

document.addEventListener("mousemove", (e) => {
  if (dragable === false) return null;
  const x = e.clientX;
  const y = e.clientY;
  const deltaX = x - position[0];
  const deltaY = y - position[1];
  const left = parseInt(element.style.left || 0);
  const top = parseInt(element.style.top || 0);
  element.style.left = left + deltaX + "px";
  element.style.top = top + deltaY + "px";
  position = [x, y];
});

document.addEventListener("mouseup", (e) => {
  dragable = false;
});
```

### 数组去重

```javascript
// 1
[...new Set(arr)];

// 2
arr.reduce((pre, now) => {
  if (!pre.include(now)) {
    pre.push(now);
  }
  return pre;
}, []);

// 3
Object.keys(
  arr.reduce((pre, now) => {
    pre.now = 1;
    return pre;
  }, {})
);
```

### 数组去纬度

去 d 纬度

```javascript
function flatDeep(arr, d = 1) {
  return d > 0
    ? arr.reduct(
        (acc, val) =>
          acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val),
        []
      )
    : arr.slice();
}
```

去除为 1 纬数组

```javascript
let flatDeep = (arr) => {
  return arr.reduce((res, cur) => {
    if (Array.isArray(cur)) {
      return [...res, ...flatDeep(cur)];
    } else {
      return [...res, cur];
    }
  }, []);
};
```

### 深拷贝

注意

- 递归
- 判断类型
- 检查环形引用
- 忽略原型

```javascript
function getType(obj) {
  const str = Object.prototype.toString.call(obj)
  const map = {
    '[object Boolean]': 'boolean',
    '[object Number]': 'number',
    '[object String]': 'string',
    '[object Function]': 'function',
    '[object Array]': 'array',
    '[object Date]': 'date',
    '[object RegExp]': 'regExp',
    '[object Undefined]': 'undefined',
    '[object Null]': 'null',
    '[object Object]': 'object'
  }
  if(obj instanceof ELement) {
    return 'element'
  }
  return map[str]
}
function deepCopy(obj) {
  const type == getType(obj)
  let copy
  switch(type) {
    case 'array':
      	return copyArray(obj, type, copy)
    case 'object':
      	return copyObject(obj, type, copy)
    case 'function':
      	return copyFunction(obj, type, copy)
    default:
      return obj
  }
}

function copyArray(ori, type, copy = []) {
  for(const [index, value] of ori.entries()) {
    copy[index] = deepCopy(value)
  }
  return copy
}

function copyObject(ori, type, copy = {}) {
  for(const [key, value] of Object.entries(ori)) {
    copy[key] = deepCopy(value)
  }
  return copy
}

function copyFunction(ori, type, copy= () => {}) {
  const fun = eval(ori.toString())
  fun.prototype = ori.peototype
  return fun
}


```

### 检测对象类型的函数

```javascript
let isTyppe = (type) => (obj) =>
  Object.prototype.toString.call(obj) === `[object ${type}]`;
```

### 手写AJAX

```javascript
let request = new XMLHHttpRequest()

request.open(method, url, true)

request.onreadystatechhange = function() {}

request.send()
```

### 正则实现trim()

```javascript
String.prototype.trim = function( {
  return this.replace(/^\s+|\s+$/g, '')
}
```