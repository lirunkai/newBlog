# 函数

说一下函数的几个注意点: **闭包** **作用域链** **原型链** **尾调用** **函数式编程** **递归**

## 添加默认值

下面给函数参数`n,y`添加默认值1和2

```
function defaultValue(n=1, y=2){

}

```

注意

1. 在函数内部不能再次用let和const声明函数的参数
2. 指明函数参数的默认值之后, length属性失效, 不会统计有默认值的参数 `(function (a, b, c = 5) {}).length // 2`


## rest参数

格式`...变量名` 用于获取函数的多余参数, 注意rest之后不能有其他参数

### 箭头函数

格式`() => {}`

特征:

1. 绑定声明时的作用域this值
2. 如果只有一个参数不用带括号
3. 如果只有一个表达式返回, 不用写return和大括号

```
let x = a => a++;

```

在其他函数中可以使用`call apply bind`来修改this的指向

### 闭包

函数A返回了函数B, 在函数B中使用了函数A的变量, 称为闭包

###  尾调用

指某个函数的最后一步是调用另一个函数

#### 尾递归优化

函数调用会在内存形成一个调用记录,保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推，形成调用栈。

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。

尾调用优化的意义: 只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，将大大节省内存.

### 递归

函数调用自身，称为递归

在函数调用时会生成调用记录, 递归的话, 会造成内存消耗严重， 优化的策略就是使用**尾递归**, 也就是在尾部调用自身, 只存在一个调用记录，不会发生内存溢出.

### 原型链

每个对象拥有一个**原型对象**，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为**原型链 (prototype chain)**

`constructor` 指向了用于构造此实例对象的构造函数.

`prototype `  类上的，该对象的原型对象

`__proto__`  实例上的,指向该对象的`prototype`

`prototype.__proto__`  上一层的原型对象, 顶层为null，null没有原型, 作为原型链的终点.

## 函数式编程



函数式编程其实知识数学编程, 只是碰巧可以写程序.

## 特征

  1. 要求函数必须使纯的，不能有副作用.
  2. 函数是第一公民

## 合成

如果一个值转变成另一个值的过程, 需要经过多个函数, 那么把多个函数合并成一个函数, 就是 `函数的合成`

```
function ride(num) {
  return num*num;
}

function add(num){
  return num + 1;
}


// 合成

const compose = function(ride, add){
  return function(x){
    return ride(add(x))
  }
}

compose(ride, add)(3) // 16

```

## 柯里化

将多个参数的函数修改为单个参数的函数

```
function add(x, y){
  return x + y;
}

// 柯里化之后

function add (x) {
  return function (y){
    return x + y;
  }
}

```

## throttle 节流

指定时间间隔内只会执行一次任务

## debounce 防抖

任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行
